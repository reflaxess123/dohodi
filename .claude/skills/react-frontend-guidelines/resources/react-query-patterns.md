# React Query Patterns (Orval)

## Auto-Generated Hooks

```typescript
// front/src/shared/api/generated/interviews/interviews.ts
// ⚠️ Auto-generated by Orval - НЕ редактировать вручную!

export const useGetInterviewCategories = (options?: UseQueryOptions<...>) => {
  return useQuery({
    queryKey: ['interview-categories'],
    queryFn: () => api.get('/api/v2/interview-categories/'),
    ...options
  });
};

export const useSearchQuestions = (params: SearchParams, options?: UseQueryOptions<...>) => {
  return useQuery({
    queryKey: ['interview-questions', params],
    queryFn: () => api.get('/api/v2/interview-categories/search/questions', { params }),
    ...options
  });
};
```

## Using Queries in Component

```typescript
// front/src/pages/Interviews/ui/InterviewsPage.tsx
import { useState } from 'react';
import { useGetInterviewCategories, useSearchQuestions } from 'shared/api/generated/interviews/interviews';
import { Loading } from 'shared/components/Loading';

export const InterviewsPage: FC = () => {
  const [searchQuery, setSearchQuery] = useState('');

  // Query для категорий
  const { data: categories, isLoading: categoriesLoading } = useGetInterviewCategories();

  // Query для поиска (с условием)
  const { data: questions, isLoading: questionsLoading } = useSearchQuestions(
    { query: searchQuery },
    { enabled: searchQuery.length > 2 } // Выполняется только если > 2 символов
  );

  if (categoriesLoading) {
    return <Loading />;
  }

  return (
    <div>
      <input
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        placeholder="Поиск вопросов..."
      />

      {questionsLoading ? (
        <Loading />
      ) : (
        <div>
          {questions?.data.map(q => (
            <div key={q.id}>{q.question_text}</div>
          ))}
        </div>
      )}
    </div>
  );
};
```

## Patterns Checklist

- ✅ Используй auto-generated хуки из `shared/api/generated/`
- ✅ Деструктуризируй `{ data, isLoading, error }`
- ✅ `enabled` для условных запросов
- ✅ Loading states для UX
- ✅ Error handling

## Mutations

```typescript
import { useCreateContentBlockMutation } from 'shared/api/generated/content/content';
import { useQueryClient } from '@tanstack/react-query';

export const CreateBlockForm: FC = () => {
  const queryClient = useQueryClient();

  const { mutate: createBlock, isPending, isError, error } = useCreateContentBlockMutation({
    onSuccess: () => {
      // Invalidate cache для рефетча
      queryClient.invalidateQueries({ queryKey: ['content-blocks'] });
      showNotification('Блок создан!', 'success');
    },
    onError: (error) => {
      showNotification(error.message, 'error');
    }
  });

  const handleSubmit = (data: CreateBlockData) => {
    createBlock({ data });
  };

  return (
    <form onSubmit={handleSubmit}>
      {isError && <div className={styles.error}>{error.message}</div>}
      {/* form fields */}
      <Button type="submit" loading={isPending}>Создать</Button>
    </form>
  );
};
```

## Optimistic Updates

```typescript
const { mutate: toggleComplete } = useUpdateBlockMutation({
  onMutate: async (newBlock) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: ['content-blocks'] });

    // Snapshot previous value
    const previousBlocks = queryClient.getQueryData(['content-blocks']);

    // Optimistically update
    queryClient.setQueryData(['content-blocks'], (old: Block[]) =>
      old.map(block =>
        block.id === newBlock.id ? { ...block, ...newBlock } : block
      )
    );

    return { previousBlocks };
  },
  onError: (err, newBlock, context) => {
    // Rollback on error
    queryClient.setQueryData(['content-blocks'], context?.previousBlocks);
  },
  onSettled: () => {
    // Refetch after mutation
    queryClient.invalidateQueries({ queryKey: ['content-blocks'] });
  },
});
```

## Infinite Queries (Pagination)

```typescript
import { useInfiniteQuery } from '@tanstack/react-query';

export const useInfiniteBlocks = () => {
  return useInfiniteQuery({
    queryKey: ['blocks-infinite'],
    queryFn: ({ pageParam = 0 }) =>
      api.get('/api/v2/blocks', { params: { skip: pageParam, limit: 20 } }),
    getNextPageParam: (lastPage, pages) => {
      if (lastPage.data.length < 20) return undefined;
      return pages.length * 20;
    },
    initialPageParam: 0,
  });
};

// Usage
const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfiniteBlocks();

const allBlocks = data?.pages.flatMap(page => page.data) ?? [];
```

## Query with Debounce

```typescript
import { useDebounce } from 'shared/hooks/useDebounce';

export const SearchComponent: FC = () => {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const { data, isLoading } = useSearchQuery(
    { query: debouncedSearchTerm },
    { enabled: debouncedSearchTerm.length > 2 }
  );

  return (
    <div>
      <input
        value={searchTerm}
        onChange={e => setSearchTerm(e.target.value)}
        placeholder="Поиск..."
      />
      {isLoading && <Loading />}
      {data?.map(item => <Item key={item.id} {...item} />)}
    </div>
  );
};
```

## Generate API Client

```bash
# Генерация из OpenAPI
npm run api:generate

# Авто-генерация при изменениях
npm run api:watch
```
